{"meta":{"title":"QuShuXian 魅影中国","subtitle":"数据分析师和Ai机器学习领域研究者","description":"魅影中国(QuShuXian),在数据分析和Ai机器学习领域持续工作近十年的研究者，欢迎数据分析、机器学习、可视化大屏领域的朋友们共同交流与分享经验!","author":"曲书贤","url":"https://qushuxian.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-29T08:17:47.157Z","updated":"2021-07-20T10:39:12.920Z","comments":false,"path":"/404.html","permalink":"https://qushuxian.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-29T08:17:47.150Z","updated":"2021-07-20T10:39:12.921Z","comments":false,"path":"about/index.html","permalink":"https://qushuxian.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2021-07-29T08:17:47.159Z","updated":"2021-07-20T10:39:12.921Z","comments":false,"path":"categories/index.html","permalink":"https://qushuxian.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-29T08:17:47.154Z","updated":"2021-07-20T10:39:12.921Z","comments":true,"path":"links/index.html","permalink":"https://qushuxian.github.io/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-07-29T08:17:47.151Z","updated":"2021-07-20T10:39:12.921Z","comments":false,"path":"books/index.html","permalink":"https://qushuxian.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-29T08:17:47.144Z","updated":"2021-07-20T10:39:12.922Z","comments":false,"path":"repository/index.html","permalink":"https://qushuxian.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-29T08:17:47.153Z","updated":"2021-07-20T10:39:12.922Z","comments":false,"path":"tags/index.html","permalink":"https://qushuxian.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python快速合并多个字段排序不规范和缺失的Excel文件","slug":"guidebook/concat_excel","date":"2021-11-17T03:16:59.000Z","updated":"2021-11-17T03:16:59.000Z","comments":true,"path":"page/guidebook/concat_excel/","link":"","permalink":"https://qushuxian.github.io/page/guidebook/concat_excel/","excerpt":"几行代码实现文件夹下所有不规范、字段参差不齐的Excel表格的快速合并。","text":"几行代码实现文件夹下所有不规范、字段参差不齐的Excel表格的快速合并。 本文章使用的表格如下： 表格1 表格2 表格3 表格4 假设有3个EXCEL表格，当然你也可以有无穷多个。 Excel表格1 省份 城市 日期 人口 河南 郑州 2021-03 620 河南 洛阳 2021-03 340 上海 上海 2021-03 1200 江苏 苏州 2021-03 530 江苏 南京 2021-03 624 Excel表格2 日期 省份 城市 城市等级 人口 2021-10 河南 郑州 二线 620 2021-10 河南 洛阳 三线 340 2021-10 上海 上海 超一线 1200 2021-10 江苏 苏州 一线 530 2021-10 江苏 南京 一线 624 Excel表格3 日期 省份 城市 城市等级 人口 人均收入 2021-11 河南 郑州 二线 620 12000 2021-11 河南 洛阳 三线 340 5605 2021-11 上海 上海 超一线 1200 12328 2021-11 江苏 苏州 一线 530 8900 2021-11 江苏 南京 一线 624 9640 对比3个表格： 每个表格的列顺序都不尽相同 每个表格里的字段都不尽相同 但有一个表格3里边的字段涵盖了表格1和表格2中的所有列，当然也有一种可能就是没有一个表格字段涵盖所有其他表格的，例如新增一个表格4 Excel表格4 日期 省份 城市 人均收入 区域负责人 2021-11 河南 郑州 12000 张三 2021-11 河南 洛阳 5605 张三 2021-11 上海 上海 12328 李四 2021-11 江苏 苏州 8900 李四 2021-11 江苏 南京 9640 李四 各个Excel表格字段对比 表格1字段 表格2字段 表格3字段 表格4字段 省份 日期 日期 日期 城市 省份 省份 省份 日期 城市 城市 城市 人口 城市等级 城市等级 人均收入 人口 人口 区域负责人 人均收入 现在的需求是把4个表格快速的合并为1个表格，但如上表格、没有统一的一个表格中的字段涵盖了所有表格，每个表格的字段顺序都不一样，so FKU。。。。。 😄哈哈哈哈 实现4个表格的逻辑主要如下： 找出所有表格的字段名字并去重 循环每个表格，第一步获取到的字段名称如果在当前循环的表格不存在、则创建字段并赋值为空 对，就2步… 12345678910111213141516171819202122232425# 根据文件所在目录，获取所有DF的key和数据paths = &#x27;/guidebook/concat_excel/&#x27;keys_list = []df_list = []for i in os.listdir(paths): df = pd.read_excel(paths + i) keys_list.append(list(df.keys())) df_list.append(df)# keys_list合并去重df_key = []for item in keys_list: for k in item: df_key.append(k)df_key = list(set(df_key))# 合并4个表格，如果某一个表格字段缺失则补充该字段并赋值为空df_excel = []for i in df_list: for k in i.keys(): if k not in i.keys(): i[k] = np.NaN df_excel.append(i)DataFrame = pd.concat([df for df in df_excel])DataFrame.reset_index(drop=True, inplace=True) 合并之后的表格效果如下","categories":[{"name":"python","slug":"python","permalink":"https://qushuxian.github.io/categories/python/"}],"tags":[{"name":"Python办公自动化","slug":"Python办公自动化","permalink":"https://qushuxian.github.io/tags/Python%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"调用Python的openpyxl包对Excel表格进行美化","slug":"guidebook/openpyxl_beautiful_excel","date":"2021-10-27T03:03:43.000Z","updated":"2021-10-27T03:03:43.000Z","comments":true,"path":"page/guidebook/openpyxl_beautiful_excel/","link":"","permalink":"https://qushuxian.github.io/page/guidebook/openpyxl_beautiful_excel/","excerpt":"Python中运用openpyxl包对Excel表格进行美化，包括字体样式调整、单元格对齐方式调整、单元格边框调整、单元格背景颜色调整、行高和列宽调整。","text":"Python中运用openpyxl包对Excel表格进行美化，包括字体样式调整、单元格对齐方式调整、单元格边框调整、单元格背景颜色调整、行高和列宽调整。 使用的Python中openpyxl包的版本为3.0.5 先看实际美化前后的效果对比 详细的开发代码如下，代码当中对关键信息进行了说明。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# =====================================================================# @Author : Shuxian.Qu# @Email : qushuxian@gmail.com# @File : beautiful_excel.py# @CreateTime : 2021-10-26 10:13# @Software : PyCharm# @Comment : 美化Excel# =====================================================================from openpyxl import load_workbook, utilsfrom openpyxl.styles import Font, PatternFill, Border, Side, Alignmentclass BeautifulExcel: def __init__(self, path, sheet_name): self.path = path self.sheet_name = sheet_name self.excel_df = load_workbook(path) def insert_row(self): &quot;&quot;&quot; 在Excel中插入指定行 &quot;&quot;&quot; self.excel_df[self.sheet_name].insert_rows(1) def insert_value(self, row, start_row, end_row, value): &quot;&quot;&quot; 在Excel的插入指定行中插入指定值 :param row: 行号 :param start_row: 开始插入行单元格的坐标 :param end_row: 结束插入行单元格的坐标 :param value: 插入的值 :return: &quot;&quot;&quot; # 指定位置插入指定值 for i in range(int(start_row), int(end_row)+1): self.excel_df[self.sheet_name].cell(row=int(row), column=i).value = value def merge_cells(self, start_row, start_column, end_row, end_column): &quot;&quot;&quot; 合并单元格 :param start_row: 合并单元格起始行号 :param start_column: 合并单元格起始行号中的起始列号 :param end_row: 合并单元格结束行号 :param end_column: 合并单元格结束行号的结束列号 :return: &quot;&quot;&quot; self.excel_df[self.sheet_name].merge_cells(start_row=start_row, start_column=start_column, end_row=end_row, end_column=end_column) def _styles(self): # 获取表格有多少行？多少列？ rows, columns = self.excel_df[self.sheet_name].max_row, self.excel_df[self.sheet_name].max_column # 定义字体样式 fonts = Font(name=&#x27;微软雅黑&#x27;, size=12, color=&#x27;000000&#x27;) # 定义单元格对齐方式 alignments = Alignment(horizontal=&#x27;center&#x27;, vertical=&#x27;center&#x27;) # 定义单元格边框颜色 sides = Side(border_style=&#x27;thin&#x27;, color=&#x27;797979&#x27;) borders = Border(left=sides, right=sides, top=sides, bottom=sides) # 定义单元格背景颜色 fills = PatternFill(&quot;solid&quot;, fgColor=&quot;FFBB02&quot;) # 定义行高和列宽 heights, widths = 15, 20 for i in range(1, int(rows)+1): for r in range(1, int(columns)+1): self.excel_df[self.sheet_name].cell(row=i, column=r).font = fonts self.excel_df[self.sheet_name].cell(row=i, column=r).alignment = alignments self.excel_df[self.sheet_name].cell(row=i, column=r).border = borders self.excel_df[self.sheet_name].cell(row=i, column=r).fill = fills for h in range(1, int(rows)+1): self.excel_df[self.sheet_name].row_dimensions[h].height = heights for w in range(1, int(columns)+1): self.excel_df[self.sheet_name].column_dimensions[utils.get_column_letter(w)].width = widths def save(self): self._styles() self.excel_df.save(self.path)be = BeautifulExcel(path=&#x27;/Users/qushuxian/Downloads/test.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;)be.insert_row()be.insert_value(row=1, start_row=1, end_row=4, value=&#x27;每日销售额统计&#x27;)be.merge_cells(1, 1, 1, 4)be.save()","categories":[{"name":"Excel","slug":"Excel","permalink":"https://qushuxian.github.io/categories/Excel/"}],"tags":[{"name":"Python办公自动化","slug":"Python办公自动化","permalink":"https://qushuxian.github.io/tags/Python%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"openpyxl","slug":"openpyxl","permalink":"https://qushuxian.github.io/tags/openpyxl/"}]},{"title":"多线程爬虫代理之随机获取UserAgent","slug":"guidebook/random_user_agent","date":"2021-10-25T08:35:32.000Z","updated":"2021-10-25T08:35:32.000Z","comments":true,"path":"page/guidebook/random_user_agent/","link":"","permalink":"https://qushuxian.github.io/page/guidebook/random_user_agent/","excerpt":"自动获取爬虫的request请求头中的user-agent代理服务，提供IE浏览器、opera浏览器、chrome浏览器、firefox浏览器、safari浏览器的伪装代理服务。","text":"自动获取爬虫的request请求头中的user-agent代理服务，提供IE浏览器、opera浏览器、chrome浏览器、firefox浏览器、safari浏览器的伪装代理服务。 该程序基于fake_useragent包进行的二次开发，需要先安装pip install fake_useragent，并自定义了get()函数，函数中设置number的用于主要是为了多线程爬虫使用，例如使用map进行并行计算等，具体代码如下： 1234567891011121314151617181920212223from fake_useragent import UserAgentimport randomdef get(number=None): &quot;&quot;&quot; 默认随机返回一组长度为number和1的UserAgent :param number: 需要返回UserAgent的列表长度，默认7 :return: &quot;&quot;&quot; ua = UserAgent() word = [ua.ie, ua.opera, ua.chrome, ua.firefox, ua.safari, ua.msie, ua.google] if number is None: user_agent_list = word return user_agent_list, random.choice(user_agent_list) elif int(number) &gt; 0: numbers = [n for n in range(int(number))] user_agent_list = [random.choice(word) for i in numbers] return user_agent_list, random.choice(word)","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://qushuxian.github.io/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"UserAgent","slug":"UserAgent","permalink":"https://qushuxian.github.io/tags/UserAgent/"},{"name":"多线程","slug":"多线程","permalink":"https://qushuxian.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"python数据处理常用方法集合","slug":"guidebook/python_def","date":"2021-09-14T02:42:52.000Z","updated":"2021-09-14T02:42:52.000Z","comments":true,"path":"page/guidebook/python_def/","link":"","permalink":"https://qushuxian.github.io/page/guidebook/python_def/","excerpt":"请在此处阐明文章摘要方便文章列表页展现。","text":"请在此处阐明文章摘要方便文章列表页展现。 pandas Dict 判断指定key是否存在？ 123456dicts = &#123; &#x27;t1&#x27;: [1, 2, 3,], &#x27;t2&#x27;: [2, 3, 4,]&#125;if &#x27;t1&#x27; in dicts: print(&#x27;Y&#x27;) List 判断指定元素是否存在 123lists = [1, 2, 3, &#x27;t1&#x27;, &#x27;t2&#x27;]if &#x27;t1&#x27; in lists: print(&#x27;Y&#x27;) 删除指定元素 12lists = [1, 2, 3, &#x27;t1&#x27;, &#x27;t2&#x27;]lists.remove(&#x27;t1&#x27;) 模糊查询元素 12345678import diffliblist1 = [&#x27;qqaabb&#x27;, &#x27;wweerr&#x27;, &#x27;121&#x27;, &#x27;qbcd&#x27;, &#x27;plqs&#x27;]# word=模糊匹配的关键字# possibilities=列表# n=返回的数量，如果有多个符合模糊匹配条件，按照匹配程度从高到低排序# cutoff=模糊匹配百分比，1代表完全匹配data = difflib.get_close_matches(&#x27;qs&#x27;, list1, 1, cutoff=0.5)","categories":[{"name":"文章分类","slug":"文章分类","permalink":"https://qushuxian.github.io/categories/%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"https://qushuxian.github.io/tags/%E6%A0%87%E7%AD%BE1/"},{"name":"标签2","slug":"标签2","permalink":"https://qushuxian.github.io/tags/%E6%A0%87%E7%AD%BE2/"}]},{"title":"python数据清洗之map和reduce函数的使用方法","slug":"guidebook/map_reduce","date":"2021-08-16T02:21:20.000Z","updated":"2021-08-16T02:21:20.000Z","comments":true,"path":"page/guidebook/map_reduce/","link":"","permalink":"https://qushuxian.github.io/page/guidebook/map_reduce/","excerpt":"文章主要实现的是使用map对传入的序列中每个元素进行计算，使用reduce对传入的序列中第一个元素进行计算后得到计算结果、再将这个结果对下一个元素进行计算，直至结束。在使用Python数据清洗时，这两个函数可以有效减少代码冗余、提升计算效率等。","text":"文章主要实现的是使用map对传入的序列中每个元素进行计算，使用reduce对传入的序列中第一个元素进行计算后得到计算结果、再将这个结果对下一个元素进行计算，直至结束。在使用Python数据清洗时，这两个函数可以有效减少代码冗余、提升计算效率等。 本篇文章既然讲Python数据清洗常用的map和reduce函数，那么首先说明下两个函数的不同点，以便有几个简单的印象。 参数不同 map接收两个参数，第一个参数是函数，第二个参数是序列(列表)，函数可以接收一个或多个参数。 reduce接收两个参数，第一个参数是函数，第二个参数是序列(列表)，但函数只能接收两个参数。 计算逻辑不同 map()是将传入的函数依次作用到序列的每个元素，每个元素都是独自被函数计算一次； reduce()是将传人的函数作用在序列的第一个元素并得到结果后，把这个结果继续与下一个元素作用，直到序列结束； 下面将通过实际的案例进行说明。 map函数的应用场景 map函数接收两个输入参数，第一个参数是函数(仅接受一个参数)、第二个参数是Iterable，由于Iterator是惰性序列( 惰性是指你不主动去遍历计算它，就不会计算其中元素的值)，因此通过list()函数让它把整个序列都计算出来并返回一个list。 map函数将传入的函数依次计算到传入序列的每个元素，并把结果作为新的Iterator返回。 map函数在Python数据清洗时迭代计算的对象是列表（也就是说只要数据放到列表中就行，理论上列表里也可以是字典、df、series等等），主要的应用场景包括： 列表的数学运算 列表的格式转换 列表的字符串分割 map函数应用案例 123456%%timeitdef function_map(x): return x * xr = list(map(function_map, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))996 ns ± 25.5 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) 上边是对list=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]中的每个元素执行了2次方的计算，代码执行时长约996纳秒。 同时，map的计算过程也可以通过for循环的方式计算，但循环的计算效率将极大地下降，如下： 1234567%%timeititems = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]squared = []for i in items: squared.append(i**2) 3.12 µs ± 162 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) 上边同样是对list=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]中的每个元素执行了2次方的计算，代码执行时长约3.12微秒，1微妙=1000纳秒，也就是说map的计算时间比for循环的计算时间缩短了3倍，map完胜。 123456789%%timeitdef function_map(x, y, z): return x + y + zx1 = [1, 2, 3, 4, 5]x2 = [1, 1, 6, 2, 3]x3 = [1, 2, 3, 4, 5]s = map(function_map, zip(x1, x2, x3))429 ns ± 12.3 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) 从计算过程看得出来map作为高阶函数、它事实上把运算规则抽象了、那么也就可以在现实工作中进行复杂的逻辑计算。 reduce函数的应用内场景 reduce函数同样是接收两个输入参数，第一个参数是函数(仅接受两个参数)、第二个参数是Iterable，细心的朋友们可能会发现这两个函数有一个不同点，那就是第一个参数函数接受的输入参数个数不同，map函数第一个参数是函数只能接受一个参数的输入，而reduce函数第一个参数是函数可以接受两个参数的输入，这在不同程度解决掉了很大计算开销的问题。 reduce函数在迭代序列的过程中，首先把列表中 前两个元素（只能两个）传给 函数，函数加工后，然后把 得到的结果和第三个元素 作为两个参数传给函数参数， 依次类推直至结束。 reduce函数在Python数据清洗时迭代计算的对象是列表（也就是说只要数据放到列表中就行，理论上列表里也可以是字典、df、series等等），主要的应用场景包括： 多个数据框join 列表的递推计算 reduce函数应用案例-多个数据框join 1234567891011121314151617def function_reduce(x, y): return pd.merge(x, y, how=&#x27;left&#x27;, on=[&#x27;id&#x27;])t1 = pd.DataFrame(&#123;&#x27;id&#x27;: [1, 2, 3, 4, 5], &#x27;name&#x27;: [&#x27;张一&#x27;, &#x27;张二&#x27;, &#x27;张三&#x27;, &#x27;张四&#x27;, &#x27;张五&#x27;]&#125;)t2 = pd.DataFrame(&#123;&#x27;id&#x27;: [1, 2, 3, 4, 5], &#x27;city&#x27;: [&#x27;上海&#x27;, &#x27;北京&#x27;, &#x27;成都&#x27;, &#x27;重庆&#x27;, &#x27;深圳&#x27;]&#125;)t3 = pd.DataFrame(&#123;&#x27;id&#x27;: [1, 2, 3, 4, 5], &#x27;occupation&#x27;: [&#x27;分析师&#x27;, &#x27;工程师&#x27;, &#x27;销售&#x27;, &#x27;HR&#x27;, &#x27;前台&#x27;]&#125;)tf = reduce(function_reduce, [t1, t2, t3])out: id name city occupation 0 1 张一 上海 分析师 1 2 张二 北京 工程师 2 3 张三 成都 销售 3 4 张四 重庆 HR 4 5 张五 深圳 前台 reduce函数应用案例-多个数据集中的并集和交集 1234567891011121314%%timeitdef function_reduce(x, y): return x &amp; ysets = [&#123;1, 2, 3, 4, 5&#125;, &#123;1, 5&#125;, &#123;2, 5, 1&#125;]s = reduce(function_reduce, sets)640 ns ± 29 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)%%timeitdef function_reduce(x, y): return x | ysets = [&#123;1, 2, 3, 4, 5&#125;, &#123;1, 5&#125;, &#123;2, 5, 1&#125;]s = reduce(function_reduce, sets)751 ns ± 31.6 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) reduce函数应用案例-转换格式并累积计算 123456%%timeitdef function_reduce(x, y): return int(x) + int(y)ls1 = [str(i) for i in range(10)]sum = reduce(function_reduce, ls1)3.62 µs ± 285 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)","categories":[{"name":"python数据清洗","slug":"python数据清洗","permalink":"https://qushuxian.github.io/categories/python%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"}],"tags":[{"name":"map","slug":"map","permalink":"https://qushuxian.github.io/tags/map/"},{"name":"reduce","slug":"reduce","permalink":"https://qushuxian.github.io/tags/reduce/"}]},{"title":"使用Python自动创建Hexo博客并生成博客缩略图","slug":"guidebook/automatic_create_hexo","date":"2021-08-03T02:35:29.000Z","updated":"2021-08-03T02:35:29.000Z","comments":true,"path":"page/guidebook/automatic_create_hexo/","link":"","permalink":"https://qushuxian.github.io/page/guidebook/automatic_create_hexo/","excerpt":"使用Python封装hexo博客框架的shell脚本，实现运行Python程序就能自动化创建hexo博客、同时实现随机给出博客使用的缩略图的URL。","text":"使用Python封装hexo博客框架的shell脚本，实现运行Python程序就能自动化创建hexo博客、同时实现随机给出博客使用的缩略图的URL。 最终效果展示 Python创建脚本效果 创建后生成的文件效果 创建后生成的缩略图效果 此处需要注意，你的hexo主题文件要支持博客的缩略的才可以，我当前使用的主题是pure，缩略图需要存放在主题的source文件夹下，如下图。 md文件头 效果 —title: 使用Python自动创建Hexo博客并生成博客缩略图thumbnail_url: /images/default_img/blog-default-4.jpgdate: 2021-08-03 10:35:29— Python脚本自动创建Hexo博客并生成博客缩略图过程 首先在项目的根目录下创建main.py文件，当然名字也可以自己定。 创建项目目录检查函数，防止main.py不是在根目录下执行。 12345678910111213141516import osimport random# 此处的dev就是项目的根目录名称，需要根据自己的情况进行命名def _mkdir(path=None, root_name=&#x27;dev&#x27;): &quot;&quot;&quot;获取项目根目录路径以及根目录下指定path的路径&quot;&quot;&quot; root = os.path.dirname(__file__) if root.split(&#x27;/&#x27;)[-1] != root_name: print(&#x27;项目根目录不正确，请检查&#x27;) else: if path is None: return root else: root_nex = os.path.join(root, path) return root_nex 修改博客默认的缩略图。前边提到的创建博客后会生成默认的缩略图，但所有的博客都使用同一个缩略图会不太美观，于是就有了针对缩略图自动修改的Python脚本。 12345678910111213141516171819202122232425262728def _random_blog_images(default_path=&#x27;themes/pure/source/images/default_img&#x27;, prd_path=&#x27;/images/default_img/&#x27;): &quot;&quot;&quot;获取blog缩略图默认的图片列表并随机选择一个，拼接生成线上使用的URL&quot;&quot;&quot; mkdir = _mkdir(default_path) default_image_list = get_file_path(mkdir) default_images = random.choice(default_image_list).split(&#x27;/&#x27;)[-1] image_path = prd_path + default_images return image_path# &#x27;thumbnail_url: &#x27;是你在post.md模板文件头中创建的缩略图变量（字段）名称def _revise_blog_thumbnail_url(blog_path, blog_thumbnail=&#x27;thumbnail_url: &#x27;): &quot;&quot;&quot;创建新博客后，输入新博客的路径信息修改默认的缩略图URL&quot;&quot;&quot; print(&#x27; 修改博客缩略图URL&#x27;) with open(blog_path) as f: blog = f.readlines() # 获取博客中默认缩略图的路径，下标 thumbnail_url = [img for img in blog if blog_thumbnail in img] print(&#x27; 创建的博客中使用的缩略图：&#x27;, thumbnail_url[0]) thumbnail_url_index = blog.index(thumbnail_url[0]) # 获取随机缩略图，替换博客中默认的thumbnail_url random_blog_images = _random_blog_images() + &#x27;\\n&#x27; random_blog_images = blog_thumbnail + random_blog_images blog[thumbnail_url_index] = random_blog_images print(&#x27; 修改后博客中使用的缩略图：&#x27;, random_blog_images) with open(blog_path, &#x27;w+&#x27;) as w: w.writelines(blog) print(&#x27; 博客缩略图URL修改成功&#x27;) 定义一个交互函数，让运行main.py文件时能够进行输入操作。 下边的&quot;2 编译博客内容并上传到Github仓库&quot;暂且不表，以后有时间再展开讲，计划是实现博客内容中的图片URL替换、搜索引擎的自动提交等等吧 12345678910111213141516171819202122232425262728293031323334353637def run_code(): types = &quot;&quot;&quot; 该程序提供如下服务内容： 1 创建新博客 2 编译博客内容并上传到Github仓库 请输入需要操作的序号: &quot;&quot;&quot; print(types) inputs = input() if 1 &lt;= int(inputs) &lt;= 2: # 1 创建新博客 if int(inputs) == 1: os.system(&#x27;cd &#123;0&#125;&#x27;.format(_mkdir())) create_blog_name, create_blog_id, create_blog_path = input(&#x27;请输入文章标题:&#x27;), input(&#x27;请输入文章ID(url使用):&#x27;), input(&#x27;请输入文章所属文件夹名称:&#x27;) create_blog = create_blog_path + &#x27;/&#x27; + create_blog_id + &#x27; &quot;&#x27; + create_blog_name + &#x27;&quot;&#x27; revise_url = create_blog_path + &#x27;/&#x27; + create_blog_id print(&#x27;将创建博客内容：&#x27;, create_blog) create_type = os.system(&#x27;hexo new post --path &#123;0&#125;&#x27;.format(create_blog)) if int(create_type) == 0: print(&#x27;创建成功&#x27;) _revise_blog_thumbnail_url(&#x27;source/_posts/&#x27; + revise_url + &#x27;.md&#x27;) else: print(&#x27;创建异常，请检查&#x27;) # 2 编译博客内容并上传到Github仓库 if int(inputs) == 2: _revise_blog_img_url() os.system(&#x27;cd &#123;0&#125;&#x27;.format(_mkdir())) # os.system(&#x27;hexo clean &amp;&amp; hexo deploy&#x27;) os.system(&#x27;hexo clean&#x27;) os.system(&#x27;hexo generate&#x27;) os.system(&#x27;cp -rf ../README.md public/&#x27;) os.system(&#x27;hexo deploy&#x27;) else: print(&#x27;输入错误，请输入(1-2)序号中需要操作的数字&#x27;) OK，使用Python自动创建Hexo博客并生成博客缩略图的完整内容就这些，非常简单且容易上手。 完整的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# @Author : 曲书贤# @File : main.py# @CreateTime : 2021/7/07 15:50# @Software : PyCharm# @Comment : hexo创建、渲染和发布博客自动化脚本import osimport randomfrom util.get import get_file_pathdef _mkdir(path=None, root_name=&#x27;dev&#x27;): &quot;&quot;&quot;获取项目根目录路径以及根目录下指定path的路径&quot;&quot;&quot; root = os.path.dirname(__file__) if root.split(&#x27;/&#x27;)[-1] != root_name: print(&#x27;项目根目录不正确，请检查&#x27;) else: if path is None: return root else: root_nex = os.path.join(root, path) return root_nexdef _random_blog_images(default_path=&#x27;themes/pure/source/images/default_img&#x27;, prd_path=&#x27;/images/default_img/&#x27;): &quot;&quot;&quot;获取blog缩略图默认的图片列表并随机选择一个，拼接生成线上使用的URL&quot;&quot;&quot; mkdir = _mkdir(default_path) default_image_list = get_file_path(mkdir) default_images = random.choice(default_image_list).split(&#x27;/&#x27;)[-1] image_path = prd_path + default_images return image_pathdef _revise_blog_thumbnail_url(blog_path, blog_thumbnail=&#x27;thumbnail_url: &#x27;): &quot;&quot;&quot;创建新博客后，修改默认的缩略图URL&quot;&quot;&quot; print(&#x27; 修改博客缩略图URL&#x27;) with open(blog_path) as f: blog = f.readlines() # 获取博客中默认缩略图的路径，下标 thumbnail_url = [img for img in blog if blog_thumbnail in img] print(&#x27; 创建的博客中使用的缩略图：&#x27;, thumbnail_url[0]) thumbnail_url_index = blog.index(thumbnail_url[0]) # 获取随机缩略图，替换博客中默认的thumbnail_url random_blog_images = _random_blog_images() + &#x27;\\n&#x27; random_blog_images = blog_thumbnail + random_blog_images blog[thumbnail_url_index] = random_blog_images print(&#x27; 修改后博客中使用的缩略图：&#x27;, random_blog_images) with open(blog_path, &#x27;w+&#x27;) as w: w.writelines(blog) print(&#x27; 博客缩略图URL修改成功&#x27;)def run_code(): types = &quot;&quot;&quot; 该程序提供如下服务内容： 1 创建新博客 2 编译博客内容并上传到Github仓库 \\n 请输入需要操作的序号: &quot;&quot;&quot; print(types) inputs = input() if 1 &lt;= int(inputs) &lt;= 2: # 1 创建新博客 if int(inputs) == 1: os.system(&#x27;cd &#123;0&#125;&#x27;.format(_mkdir())) create_blog_name, create_blog_id, create_blog_path = input(&#x27;请输入文章标题:&#x27;), input(&#x27;请输入文章ID(url使用):&#x27;), input(&#x27;请输入文章所属文件夹名称:&#x27;) create_blog = create_blog_path + &#x27;/&#x27; + create_blog_id + &#x27; &quot;&#x27; + create_blog_name + &#x27;&quot;&#x27; revise_url = create_blog_path + &#x27;/&#x27; + create_blog_id print(&#x27;将创建博客内容：&#x27;, create_blog) create_type = os.system(&#x27;hexo new post --path &#123;0&#125;&#x27;.format(create_blog)) if int(create_type) == 0: print(&#x27;创建成功&#x27;) _revise_blog_thumbnail_url(&#x27;source/_posts/&#x27; + revise_url + &#x27;.md&#x27;) else: print(&#x27;创建异常，请检查&#x27;) # 2 编译博客内容并上传到Github仓库 if int(inputs) == 2: _revise_blog_img_url() os.system(&#x27;cd &#123;0&#125;&#x27;.format(_mkdir())) # os.system(&#x27;hexo clean &amp;&amp; hexo deploy&#x27;) os.system(&#x27;hexo clean&#x27;) os.system(&#x27;hexo generate&#x27;) os.system(&#x27;cp -rf ../README.md public/&#x27;) os.system(&#x27;hexo deploy&#x27;) else: print(&#x27;输入错误，请输入(1-2)序号中需要操作的数字&#x27;)if __name__ == &#x27;__main__&#x27;: run_code() 如有问题，欢迎留言~","categories":[{"name":"Hexo系列","slug":"Hexo系列","permalink":"https://qushuxian.github.io/categories/Hexo%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"python自动化创建博客","slug":"python自动化创建博客","permalink":"https://qushuxian.github.io/tags/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"Git删除本地提交记录和GitHub忽略文件设置","slug":"guidebook/git","date":"2021-07-30T03:30:44.000Z","updated":"2021-08-02T03:30:44.000Z","comments":true,"path":"page/guidebook/git/","link":"","permalink":"https://qushuxian.github.io/page/guidebook/git/","excerpt":"使用git操作删除一些本地错误提交的记录，.gitignore忽略文件未生效的解决方案。","text":"使用git操作删除一些本地错误提交的记录，.gitignore忽略文件未生效的解决方案。 查看Git提交记录 git log --oneline 该命令为查看git提交记录的精简版信息 如果想查看git提交记录的全部信息，请输入 git log 删除Git提交到本地最后一条记录 git reset --hard HEAD~1 若想要删除最后提交的n记录，将 1 替换为一个具体的数字 n 即可。 .gitignore忽略文件未生效 在项目开发过程中，把特定目录或文件加入.gitignore忽略规则，但提交代码是发现忽略规则并未生效，究其原因是.gitignore只能忽略那些原来没有被跟踪的文件，你在项目开发过程中加入忽略规则的某些文件本身已经被纳入了版本管理中，则修改.gitignore是无效的。 那么解决这种问题的方法就是先把本地Git缓存删除，然后再提交： git rm -r --cached . git add . git commit -m 'update .gitignore' 切记，.gitignore文件必须是在项目的根目录下，否则不会生效。","categories":[{"name":"git","slug":"git","permalink":"https://qushuxian.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://qushuxian.github.io/tags/git/"},{"name":".gitignore","slug":"gitignore","permalink":"https://qushuxian.github.io/tags/gitignore/"}]},{"title":"Hexo使用指南","slug":"guidebook/hexo","date":"2021-07-20T07:25:15.000Z","updated":"2021-07-20T07:25:15.000Z","comments":true,"path":"page/guidebook/hexo/","link":"","permalink":"https://qushuxian.github.io/page/guidebook/hexo/","excerpt":"该文章主要包含： hexo常用shell命令 用Python包装常用shell命令 Python实现hexo博客随机缩略图 Python实现hexo博客图片url的自动修改 Python实现hexo博客自动编译并发布","text":"该文章主要包含： hexo常用shell命令 用Python包装常用shell命令 Python实现hexo博客随机缩略图 Python实现hexo博客图片url的自动修改 Python实现hexo博客自动编译并发布 创建新的文档（根目录下） 在根目录中执行下列shell命令，表示根据scaffolds中的post模板在source/_posts下创建guidebook/hexo文件夹、同时创建同名的md文档，文档内部指定文章的标题为Hexo使用指南 1hexo new post --path guidebook/hexo &quot;Hexo使用指南&quot; 编译md文档 运行如下命令渲染并编译开发环境中的md文档 → 生成html → 推送到代码仓库 1hexo clean &amp;&amp; hexo deploy 创建hexo项目 123# 创建hexo项目并命名为bloghexo init blogcd blog 创建blog项目后，将生成如下文件： 123456789├── _config.landscape.yml├── _config.yml # 配置文件├── db.json├── node_modules # 开发环境node依赖├── package-lock.json├── package.json # hexo运行指令和依赖的npm├── scaffolds # 模板文件├── source # md文档存储文件，渲染时会根据该文件下的文件路径和文件名称生成URL，避免使用中文└── themes # 主题配置 为了编译后自动推送到GitHub仓库，需要安装hexo-deployer-git 1npm install hexo-deployer-git --save 主题设置 yilia-plus pure 该主题支持颜色 theme-black，theme-blue，theme-green，theme-purple 使用该主题，需要将themes/pure/_source下的所有文件拷贝至根目录下的themes文件夹，如下： 12345678910── source ├── 404 ├── _data ├── _posts ├── about ├── books ├── categories ├── links ├── repository └── tags 该主题的详细配置可以再themes/pure/_config.yml进行","categories":[{"name":"Hexo系列","slug":"Hexo系列","permalink":"https://qushuxian.github.io/categories/Hexo%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://qushuxian.github.io/tags/hexo/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://qushuxian.github.io/categories/python/"},{"name":"Excel","slug":"Excel","permalink":"https://qushuxian.github.io/categories/Excel/"},{"name":"爬虫","slug":"爬虫","permalink":"https://qushuxian.github.io/categories/%E7%88%AC%E8%99%AB/"},{"name":"文章分类","slug":"文章分类","permalink":"https://qushuxian.github.io/categories/%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/"},{"name":"python数据清洗","slug":"python数据清洗","permalink":"https://qushuxian.github.io/categories/python%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"},{"name":"Hexo系列","slug":"Hexo系列","permalink":"https://qushuxian.github.io/categories/Hexo%E7%B3%BB%E5%88%97/"},{"name":"git","slug":"git","permalink":"https://qushuxian.github.io/categories/git/"}],"tags":[{"name":"Python办公自动化","slug":"Python办公自动化","permalink":"https://qushuxian.github.io/tags/Python%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"openpyxl","slug":"openpyxl","permalink":"https://qushuxian.github.io/tags/openpyxl/"},{"name":"UserAgent","slug":"UserAgent","permalink":"https://qushuxian.github.io/tags/UserAgent/"},{"name":"多线程","slug":"多线程","permalink":"https://qushuxian.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"标签1","slug":"标签1","permalink":"https://qushuxian.github.io/tags/%E6%A0%87%E7%AD%BE1/"},{"name":"标签2","slug":"标签2","permalink":"https://qushuxian.github.io/tags/%E6%A0%87%E7%AD%BE2/"},{"name":"map","slug":"map","permalink":"https://qushuxian.github.io/tags/map/"},{"name":"reduce","slug":"reduce","permalink":"https://qushuxian.github.io/tags/reduce/"},{"name":"python自动化创建博客","slug":"python自动化创建博客","permalink":"https://qushuxian.github.io/tags/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"name":"git","slug":"git","permalink":"https://qushuxian.github.io/tags/git/"},{"name":".gitignore","slug":"gitignore","permalink":"https://qushuxian.github.io/tags/gitignore/"},{"name":"hexo","slug":"hexo","permalink":"https://qushuxian.github.io/tags/hexo/"}]}